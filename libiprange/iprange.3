.TH libiprange 3
.SH NAME
.B iprange_init(), iprange_close(), iprange_geterror(), iprange_setdomain(),
.B iprange_query_start(), iprange_query_check(), iprange_query_cancel(),
.B iprange_settimeout(), iprange_setcallbackint(), iprange_setcallbackctx(),
.B iprange_setdnscallback(), iprange_dns_set_query_service(),
.B iprange_dns_set_query_start(), iprange_dns_set_query_cancel(),
.B iprange_dns_set_query_waitreply()
-- range-based Real-time Block List (RBL) query service
.SH SYNOPSIS
#include
.I <iprange.h>

RBL *
.B iprange_init
(void *(*
.B mallocf
)(void *, size_t), void (*
.B freef
)(void *, void *p), void *
.B closure
);

unsigned char *
.B iprange_geterror
(RBL *
.B iprange
);

void
.B iprange_setdomain
(RBL *
.B iprange,
unsigned char *
.B qroot
);

IPRANGE_STAT
.B iprange_query_start
(RBL *
.B iprange,
unsigned char *
.B query,
void **
.B qh
);

IPRANGE_STAT
.B iprange_settimeout
(RBL *
.B iprange,
unsigned int
.B timeout
);

IPRANGE_STAT
.B iprange_setcallbackint
(RBL *
.B iprange,
unsigned int
.B cbint
);

IPRANGE_STAT
.B iprange_setcallbackctx
(RBL *,
.B iprange,
void *
.B ctx
);

IPRANGE_STAT
.B iprange_setdnscallback
(RBL *,
.B iprange,
void (*
.B func
)(const void *));

void *
.B iprange_dns_set_query_service
(RBL *
.B iprange,
void *
.B svc
);

void
.B iprange_dns_set_query_cancel
(RBL *
.B iprange,
int (*
.B func
)(void *, void *));

void
.B iprange_dns_set_query_start
(RBL *
.B iprange,
int (*
.B func
)(void *, int, unsigned char *, unsigned char *, size_t, void **));

void
.B iprange_dns_set_query_waitreply
(RBL *
.B iprange,
int (*
.B func
)(void *, void *, struct timeval *, size_t *, int *, int *));

void
.B iprange_close
(RBL *
.B iprange
);

.SH DESCRIPTION
These functions are an interface to a facility to conduct Realtime Blacklist
(RBL) queries that use the draft specification for IP range publications,
and return their results.  Basic RBLs are described in RFC5782; range-based
RBLs are defined in draft-levine-iprangepub.

An application first initializes the package by calling
.B iprange_init().
The optional
.I mallocf
parameter is a caller-provided memory allocation function taking a pointer
to a caller-provided opaque data structure (the
.I closure
parameter) and a number of bytes to allocate.  If
.I mallocf
is not provided, the default system memory allocator function
.B malloc(3)
is used.  The optional
.I freef
parameter specifies a matching caller-provided memory deallocator function,
taking a pointer to a caller-provided opaque data structure (the
.I closure
parameter) and a pointer to the memory to be released.  If
.I freef
is not provided, the default system memory release function
.B free(3)
is used.  A handle for future use of the initialized library instance
is returned, or NULL on error and
.I errno
will be set to indicate the cause of the failure.

The
.B iprange_geterror()
function can be used to poll the library for an error string that provides
further description for the most recent failed operation.

A call to
.B iprange_setdomain()
sets the RBL's base domain.  This specifies the "root" of all future queries
for the provided
.B iprange
handle to
.B qroot.
Future queries passed to this handle will be prepended to the string
provided here.

A query is initialized with a call to
.B iprange_query_start()
which takes an IP range library handle as
.B iprange,
the string to be queried as
.B query,
and a pointer to a void pointer that will be updated to contain a reference
to the initiated query as
.B qh.

A query previously started by
.I iprange_query_start()
can be canceled by calling
.B iprange_query_cancel(),
passing it an IP range library handle as
.B iprange
and a query handle as 
.B qh
as previously returned when the query was started.

A query previously started by
.I iprange_query_start()
can be polled for its status or a result using
.B iprange_query_check(),
passing it an IP range library handle as
.B iprange,
a query handle as 
.B qh,
a pointer to a "struct timeval" ast
.B timeout
(which can be NULL if an infinite wait is acceptable), and a pointer to
a 32-bit integer as
.B res
into which any result will be returned (or it can be NULL if the caller
doesn't actually want the result).  Results are in network byte order.
If this function returns IPRANGE_STAT_FOUND or IPRANGE_STAT_NOTFOUND, the query
is automatically canceled and need not be passed to
.I iprange_query_cancel().

The
.B iprange_settimeout()
function can be used to change the query timeout.  The default is ten seconds.
This applies to each DNS activity individually, and a single query through
this interface may be made up of more than one such query.

If it is useful to have the library periodically call a user-provided function
as an indication that queries are still in progress, such a function can be
registered with the
.B iprange_setdnscallback()
function.  The function provided should take a void context pointer as
its sole argument.
.B iprange_setcallbackctx()
is used to tell the library what context pointer should be used, and
.B iprange_setcallbackint()
is used to tell the library what frequency, in seconds, should be used to
call that callback function.  Each of these takes the corresponding RBL
library handle as its first argument, and the obvious parameter for its second.

By default, the library will use the stock system resolver to conduct DNS
queries.  If alternates should be used, these can be specifed using the
following functions:

.B iprange_dns_set_query_service()
sets a context pointer to the query service to be used, if any.  This will
be passed as-is to the other DNS functions.  It returns its previous value.

.B iprange_dns_set_query_cancel()
sets a pointer to the function that should be called to cancel an open query,
and should take the following parameters: a void pointer to the DNS query
service to be used, and a void pointer to a query handle as previously returned
by a call to
.I iprange_dns_set_query_start().
The function should return one of the DNS result codes described below.

.B iprange_dns_set_query_start()
sets a pointer to the function that should be called to initiate a new query,
and should take the following parameters: a void pointer to the DNS query
service to be used, a DNS record type (e.g. T_TXT), a pointer to a string
containing the query to be started, a pointer to a buffer into which the
reply should be written, the number of bytes available in that buffer,
and a pointer to a void pointer that will be updated to contain a unique
handle for that query once started.  The function should return one of the
DNS result codes described below.

.B iprange_dns_set_query_waitreply()
sets a pointer to the function that should be called to wait for a reply
to an open query, and should take the following parameters: a void pointer
to the DNS query service to be used, a void pointer referencing the query of
interest as previously returned by a call to
.I iprange_dns_set_query_start(),
a pointer to a "struct timeval" structure indicating how long the function
should wait for a reply (or NULL if infinite waiting is acceptable),
a pointer to a "size_t" that will be updated to contain the size of the
received reply, a pointer to an integer that will contain an error code
if the query fails (can be NULL if that information is not interesting to
the caller), and a pointer to an integer that will contain a DNSSEC
status indication (can be NULL if that information is not interesting to
the caller).  The function should return one of the DNS result codes
described below.

When the library handle is no longer needed, it should be passed to
.B iprange_close().

.SH RETURN VALUES
The following return codes, of type IPRANGE_STAT, can be returned:
.TP
.I IPRANGE_STAT_OK
successful completion
.TP
.I IPRANGE_STAT_INVALID
operation failed because an invalid parameter was provided
.TP
.I IPRANGE_STAT_DNSERROR
operation could not be completed because of errors requesting or receiving
a DNS reply; note that this does not include a successful reply that contains
a "no record found" result, which is a successful answer
.TP
.I IPRANGE_STAT_NORESOURCE
a caller-provided buffer was too small to complete the requested operation,
or a memory or file descriptor allocation failed
.TP
.I IPRANGE_STAT_NOTIMPLEMENT
an optional library feature was not selected at compilation time
.TP
.I IPRANGE_STAT_FOUND
the requested record was found in the RBL
.TP
.I IPRANGE_STAT_NOTFOUND
the requested record was not found in the RBL (but the query did complete)
.TP
.I IPRANGE_STAT_NOREPLY
a call to
.I iprange_query_check()
timed out before a result could be returned
.TP
.I IPRANGE_STAT_EXPIRED
the underlying resolver reported that the query expired; this is included to
support resolvers that have an overall query timeout as well as a single
wait timeout
.SH DNS RETURN CODES
Any registered DNS functions should return one of the following result codes:
.TP
.I IPRANGE_DNS_ERROR
An error occurred.  The cause of the error can be retrieved using
.I iprange_geterror().
.TP
.I IPRANGE_DNS_SUCCESS
The operation was successful.
.TP
.I IPRANGE_DNS_REPLY
A reply is available (returned by the "waitreply" function).
.TP
.I IPRANGE_DNS_NOREPLY
No reply was received by the time the query timeout was reached (returned
by the "waitreply" function).
.TP
.I IPRANGE_DNS_EXPIRED
The query expired completely (returned by the "waitreply" function).  Some
resolvers set an overall timeout for the query at start time in addition to
one for each single wait request; this code indicates the former timeout
expired.
.SH COPYRIGHT
Copyright (c) 2011, The OpenDKIM Project.  All rights reserved.
.SH SEE ALSO
.I intro(2)
